\chapter{Related Work}
\label{chap:related}

At its core, the goals of my proposed work are threefold:

\begin{packed_item}
\item Quantify and analyze the trust and threat models inherent in
  modern third-party backed cloud computing solutions.
\item Provide primitives that allow user to minimize, manage, and
  monitor the degree to which they must trust or expose sensitive
  information to third parties.
\item Use such primitives to create security and privacy enhancing
  systems well adopted for a range of modern common and desirable use
  cases.
\end{packed_item}

There are a number of related efforts that also seek to fulfill one or
more of these goals. I discuss some of the more pertinent of these
efforts in this section.

\section{Trust, Threat, and Security Models}
\label{chap:related:models}

Security researchers have developed a number of trust, threat, and
security models for a range of computing systems. Some of these models
are concerned merely with the technical security of the system. Others
expand to account for the many proclivities of human behavior that
have bearings on the security and privacy of computing systems. In all
cases, such models seek to answer the questions:

\begin{packed_item}
\item ``On what assumptions does the security of a given system rest?''
\item ``In what manner can those assumptions be violated?''
\item ``What is the effect of violating such assumptions?''
\end{packed_item}

Security models are a critical part of designing any security
systems. The security of any given system is only as good as it;s
weakest link. Security models provide an analyses if the various links
within and surrounding any given security or privacy enhancing system
-- links that must be considered when determining the overall
guarantees provided by a given system as well as the exposure of a
given system to various threats.

\cite{flowerday2006} provides an analyses if how trust and related
human controls must be considered in the design of any information
security system. It builds on work in outside the traditional computer
science space related to theories of trust and privacy in government,
law, and society~\cite{Camp2003}. These works lay the foundation for
trust analysis in computing systems and tie the concept of trust in
computing systems to wider theories of trust in privacy as fundamental
concepts.

Beyond trust analyses, there are a number of more general compute
security models and taxonomies that tend to focus on more traditional
technical and operational risks and mitigations. ~\cite{Abbas2005}
discuses security and threat models for Internet-connected
services. ~\cite{Tsipenyuk2005} focuses on common failures in
application-level security. ~\cite{Firesmith2005} dives into an more
abstract analysis of safety and security in computing systems and
provides a framework for analysis software security risks, potential
harms, amid security requirements. Finally, ~\cite{Cebula2010} takes a
comprehensive look at operational cyber-security risks across
technical, human, process, and external possibilities.

While all of these efforts provided a basis for trust, threat, and
security analysis of computing systems, they do not dive into the
specific intricacies of modern third-party trust inherent in cloud
computing systems. This is a deficiency on which I focus in the
proposal and my future proposed thesis work.

\section{Minimizing Third Party Trust}

Uneasiness with having to trust third parties has led to a number of
efforts to reduce, limit, and control such trust. Many of these
solution aim to leverage cryptographic primitives as an alternative to
a trusted third party (TPP). As mentioned in
Section~\ref{chap:background:crypto}, cryptographic-based system
require no trust in external systems or parties, only in the
underlying math. Others use information theory primitives such as the
secret sharing schemes also discussed in
Section~\ref{chap:background:crypto} to try to limit how much damage
any single trusted third party can do: forcing multiple third parties
to collude to accomplish most attacks. In many cases, these explore
the trade-offs between the convenience and capabilities that trusted
third party systems can provide and the security risks of requiring
one of more trusted third parties.

\subsection{Cryptographic Access Control}

The primary limitation of all of the access control models mentioned
in Section~\ref{chap:background:ac} is their reliance on a trusted
arbiter for enforcement: generally this trusted arbiter is the
operating system or third party system in charge of enforcing the
access control system. This means that the security of any of these
access control systems is only as good as the security of the system
or third party enforcing them. Thus, if the underlying OS or third
party is compromised, the access control system falls apart. Likewise,
anyone in control of the underlying OS or enforcement system (e.g. an
administrator) automatically gains full control over the access
control system. This is an acceptable limitations in many situations,
especially those based on a centrally managed system with existing
physical security and administrative safeguards in place. But in
distributed systems or the cloud where physical and management control
in not guaranteed, a more robust system that lacks this ``trusted
arbiter'' requirement is desirable.

To overcome the need for a trusted enforcement mechanism in access
control systems, researchers have turned to cryptographically-based
access control systems. \cite{Goyal2006} and \cite{Bethencourt2007}
propose several cryptographically-based access control systems. These
systems are based on the concept of Attribute-Based Encryption (ABE)
schemes. ABE schemes allow a user to encrypt a document in a manner
such that the access control rules associated with the document are
part of the encryption process itself. Thus, in order to
decrypt/access a document, a user must satisfy one or more
cryptographically guaranteed access control attributes.
\cite{Goyal2006} allows user to encrypt documents that can only be
decrypted by users possessing specific attribute polices encoded in
their keys. \cite{Bethencourt2007} extends this concept to allow
documents to be encrypted with a full access control policy embedded
in the encryption process itself, allowing only users who's private
keys meet a generalized set of requirements to access the
documents. Both these systems allow the construction of access control
systems that do not require any trusted arbiter to regulate access to
objects. Instead, the access control policy is enforced by the
underlying encryption itself.

Such concepts have not yet been widely deployed in day-to-day use,
possibly because of the complexity and computational overhead of
building and operating such systems. These systems also still push off
the generation, storage, and management of private keys to end users
and administrators, raising many of the same key-management challenges
discussed in Section~\ref{chap:challenges:solutions}.

\subsection{Homomorphic Encryption}

The rise of the cloud as the home to much modern data processing
systems has led to questions about the degree to which third-party
cloud providers should be trusted with access to the data processed on
their infrastructure. Homomorphic Encryption systems are designed to
help mitigate this trust. Such systems are designed to perform data
processing operations on encrypted data directly, avoiding the need to
decrypt it and expose the unencrypted form to a third party.

The previous few years have heralded the arrival of numerous
partially-homomorphic encryption systems capable of performing certain
classes of data processing and manipulation operations directly on
encrypted data. System like CryptDB~\cite{popa2011} allow users to
search and query encrypted data directly, allowing the storage of such
databases on untrusted infrastructure. Other systems like
CS2~\cite{kamara2011} provided similar protections and capabilities
for more generic data storage contexts. Such systems are referred to
as partially homomorphic schemes since they only allow a subclass of
all possible operations to be performed on encrypted data. Such
systems have been fielded and shown to be practical today.

Beyond partially homophobic encryption schemes, fully homomorphic
encryption schemes allow for unrestricted classes of operations to be
performed on encrypted data~\cite{gentry2009}. A number of such
systems have been proposed - some of which go as far as to propose the
possibility for encrypting computer programs themselves that can then
be executed by a fully homomorphic processor~\cite{Breuer2013,
  Brenner2011}. Such system are certainly appealing, but thus far
building one with suitable low overhead so as to be practical today
has proven elusive.

While homomorphic solutions likely will prove to be part of the
solution to the problem of third party trusty in the cloud, they don't
inherently solve all of the problems. In the practical since, the
available systems today are limited to only preforming certain
operations. Furthermore, while such systems allow the processing of
data atop untrusted infrastructure, they do not provide a solution for
the cases where you wish to share plain-text data with other users or
otherwise assert a use case that requires data to be decrypted in
order to achieve.

\subsection{Secure Storage}

Beyond data processing, the ability to securely store data atop third
party infrastructure while also minimizing the degree to third party
trust this entails has been and remains a desirable goal. As such, a
number of projects have undertaken efforts aimed at achieving such
protections.  Secure data storage is one of the most targeted areas by
security and privacy enhancing systems. And for good reason -- the
ability to security store data is a key primitive for maintaining the
security and privacy of our computing systems.

A number of traditional client-server encrypted file systems exist
with the design goal of avoiding server-side
trust~\cite{Kher2005}. Systems like CryptoCache~\cite{jensen2000},
RFS~\cite{dong2011}, and Plutus~\cite{kallahalla2003} are all designed
to allow users to store files on servers without trusted the server
itself. Other systems like Keypad~\cite{geambasu2011} and
CleanOS~\cite{tang2012} are aimed at securing data atop user devices
and protecting that data when a device is lost or stolen. All of these
systems deploy various forms of cryptography to obtain their goals.
 
Beyond traditional client-server secure storage systems, distributed
storage systems like Depot~\cite{mahajan2011},
OceanStore~\cite{kubiatowicz2000}, and Tahoe~\cite{wilcox-o'hearn2008}
are all designed to minimize trust in the underlying storage
infrastructure. Such systems allow users to distribute and store files
across many third-party hosted nodes while also ensuring that the
failure, either accidental or intentional, of a subset of nodes does
not result in the loss, corruption, or exposure of user data. Depot
focuses on data integrity and availability in the presence of
untrusted nodes. Tahoe focus on data integrity privacy in the response
of untrusted nodes. OceanStore has elements of both as well as a focus
on large scale deployments that account for properties like locality
to enhance performance.

In many of these systems, however, key management primitives are still
ignored or pushed down to the user, leading to usability issues and
use-case mismatches. My proposed work could be used to extend such
designs to better account for the key management challenges limiting
the use of such systems today.

\section{Enhancing End-User Security}
\cite{openpgp, pgp, gnupg}
\cite{enigmail, mailpile, Koch2011}
\cite{lastpass, onepassword, apple-icloud}
\cite{schneier-passwords, krebs-passwords, brodkin-passman}.
\cite{spideroak}

Password management systems (e.g.~\cite{lastpass} share some of the
same goals as Custos and can be viewed as a subset of the more generic
SSaaS model. Such systems are designed to enable users to use longer,
less predictable passwords by providing a dedicated system that stores
and fills password feels on a user's behalf. The user must only
remember a single strong password, relying on the password manager to
store and supply long random passwords for all the other services a
user leverages. Custos could be used as the secret storage back end
for a range of existing password manager front ends, providing more
flexible password access control semantics in the process and allowing
the user to select a SSaaS provider of their choice.

\section{Key Management and Key Escrow Systems}
\cite{Blaze1996, Denning1996}
\cite{cloudkeep-presentation, cloudkeep}
\cite{gazzang, porticor, Rosen2012}
\cite{amazon-hsm}

Rackspace's CloudKeep~\cite{cloudkeep} aims to create a standardized
key management system for use across multiple applications, avoiding
the need to re-implement such systems in each application. Similar to
Custos, CloudKeep aims to ease developer burden while increasing the
security of end-user applications by focusing security code in a
centralized, carefully curated system. CloudKeep, however, lacks the
generic flexibility and powerful semantics of Custos's authentication
and access control mechanisms.

As we have shown, however, many
of these system suffer from the entanglement of key management and the
underlying encryption. We are not the first to recognize the
challenges this entanglement imposes. SFS~\cite{Mazieres1999} and
Plutus~\cite{kallahalla2003} were designed to separate cryptographic
key management from encrypted data storage, allowing for more flexible
key management in the process. But both SFS and Plutus fail to fully
define a standardized, generic, and flexible external system for
storing and managing keys, making a generic ``Secret Storage as a
Service'' architecture impossible to realize with either system. In
particular, SFS purposely avoids specifying any key management
solution, instead focusing on mechanisms that allow the user to select
their own key management system (e.g. Custos). Plutus provides basic
key management functionality, but it bundles these tightly with the
underlying file system, forcing the user to use both or neither and
preventing the user from selecting dedicated third party SSaaS
providers.


%%  LocalWords:  CryptoCache OceanStore SFS Plutus Custos SSaaS TPP
%%  LocalWords:  Rackspace's CloudKeep Custos's CryptDB CleanOS
