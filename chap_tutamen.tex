\chapter{Tutamen: Next-Generation Secret Storage}
\label{chap:tutamen}

While Custos (Chapter~\ref{chap:custos}) provides a sound
first-generated secret storage system, it also has a number of flaws
that make solving some of the more nuanced secret storage challenges
difficult. To overcome these challenges, I create Tutamen - a next
generation secret storage system. Tutamen takes the lessons learned
from building Custos and applies them to create a next-generation
secret storage system with native support for multi-provider secret
sharding and automated secret access.

\section{A New Approach}
\label{chap:tutamen:new}

\subsection{Flaws in Custos}



\subsection{The Ideal Secret Storage System}

Unlike standard configuration management systems, or even specific
secret storage systems such as password managers, a general purpose
secret storage presents a number of unique requirements, including the
following capabilities:

\begin{packed_item}
\item Store a wide-range of arbitrary secret data
\item Store secret data in a secure manner
\item Enforce fine-grained access control requirements
\item Support a range of authentication sources/methods
\item Provide audit logs tracking secret access history
\end{packed_item}

In response to these needs, a number of general purpose secret storage
systems have been recently developed by industry, including
HashiCorp's Vault~\cite{vault}, Lyft's Confidant~\cite{confidant}, and
Square's Keywhiz~\cite{keywhiz}. These systems exist to fulfill some
or all of the requirements listed above. We believe, however, that
such systems are hindered by several key limitations. First, they
generally require at least one fully trusted server as the basis of
their security model, making them unsuitable for operation atop
untrusted infrastructure. Second, they tend to lack support for use
cases requiring autonomous or remote access to secret material in a
secure manner. These deficiencies give rise to a few more secret
storage requirements:

\begin{packed_item}
\item Avoidance of the need to place a high degree of trust in any
  single system outside the application that wishes to store a secret.
\item Ability to support a range of secret access use cases, including
  use cases where automatic or remote access to secrets is required.
\end{packed_item}

It is toward these final two requirements that Tutamen attempts to
advance the state of the art over existing secret storage systems. In
particular, Tutamen supports operational modes where no single entity
other than the application must be trusted. This allows users to
leverage third party secret storage providers running Tutamen servers
without having to place high degrees of trust in any single
provider. Tutamen also provides support for a modular authentication
interface. This interface makes Tutamen suitable for use in situations
where it is desirable to leverage external environmental information
to automatically evaluate the authenticity of a secret request or
where it is necessary to keep a human in the authentication loop
without actually requiring that the human be physically present. For
example, Tutamen can be used to store the disk encryption keys
required to boot a headless server, and only release these keys to the
server requesting them when a human responds to a text message
confirming the boot request.


\section{The Tutamen Platform}
\label{chap:tutamen:platform}

The Tutamen Secret Storage Platform is designed to handle the storage
of arbitrary secret material from a range of applications. In this
section, we present the Tutamen architecture and our reference Tutamen
server implementations.

\subsection{Architecture}
\label{chap:tutamen:platform:arch}

Tutamen has three discreet architectural components:

\begin{packed_desc}
\item[Access Control Servers (ACS):] The systems responsible for
  storing and enforcing secret access control requirements and for
  authenticating secret requests.
\item[Storage Servers (SS):] The systems responsible for storing
  secrets (or parts of secrets).
\item[Applications:] The systems leveraging the Tutamen platform to
  store and retrieve secrets.
\end{packed_desc}

The bulk of all Tutamen communication occurs between an application
and one or more of each type of server. Inter-server communication is
kept to a minimum to support scalability. All communication in Tutamen
takes place via TLS~\cite{dierks2008} HTTPS connections, and in some
cases leverages mutual TLS to provide both client and server
authentication. Both access control and storage servers are designed
to be used individually or in sets. E.g., an application may store its
secrets on a single storage server and delegate access control to a
single access control server, or the application may shard its secrets
across multiple storage servers and delegate access control to
multiple access control servers, or any combination thereof.

\subsubsection{Access Control Servers}
\label{chap:tutamen:platform:arch:acs}

Tutamen access control servers (ACS) are responsible for
authenticating Tutamen requests as well as storing and enforcing all
Tutamen access control requirements. Access control servers expose a
number of core data structures that reflect the manner in which they
operate. Figure~\ref{fig:tutamen:acstructs} shows these structures.

\begin{figure}[t]
  \centering
  \includegraphics[width=0.48\textwidth]{./figs/out/Tutamen-Structs-ACS.pdf}
  \caption{Access Control Server Data Structures}
  \label{fig:tutamen:acstructs}
\end{figure}

In order to track and control access from specific actors, the access
control server uses per-actor accounts. These accounts are generally
designed to map to individual end users, but they can be used to track
any entity to which one wishes to assign specific access control
privileges. Accounts thus form the basis of controlling and sharing
access to secrets via Tutamen. Within each account are one or more
clients. While accounts represent logically singular entities, clients
represent specific devices controlled by such entities. Each account
has one or more clients. For example, Jane Coworker may have a single
account with three clients: one for her laptop, one for her desktop,
and one for her phone.

Each client is associated with a single x509~\cite{rfc5280} TLS
key/cert-pair used to authenticate the client to the access control
server. The access control server acts as the Certificate Authority
(CA) administering these certificates. When a new client is created it
generates a local private key and uses this key to generate an X509
Certificate Signing Request (CSR). This request is then sent to the
access control server where it awaits approval from an existing client
in the account. If approved, the CSR is used to generate a signed
certificate that is sent back to the new client for use in future ACS
communication. To facilitate bootstrapping new accounts, client CSRs
are also generated and sent during new account creation. These are
automatically approved and associated with the new account -- i.e.,
the initial client is created in tandem with a new account while all
subsequent clients are approved by previously approved clients.

In addition to accounts, the Tutamen access control server also uses
``authenticators''. Authenticators are modular mechanisms used to
implement contextual access control requirements~\cite{hulsebosch2005}
such as only allowing access during specific times of day or from
specific IP addresses. Authenticators can also be used to implement
multi-factor and/or alternate-band authentication mechanisms such as
confirming approval for a specific request from a user via text
message, or otherwise interfacing with external services to gain
approval.

Accounts and authenticators are combined via verifiers. A verifier
consists of a set of accounts and a set of authenticators. In order to
satisfy a verifier, a request must originate from a client associated
with one of the member accounts and must satisfy all of the member
authenticators. A verifier may contain no authenticators, in which
case authorization is granted solely on the basis of accounts.

The final component of the Tutamen access control server is the
permissions group. Each permissions group corresponds to a specific
object (identified via the combination of an object type and an object
ID) within the Tutamen ecosystem. A permissions group contains one or
more permissions, each corresponding to a specific class of actions
that can be performed on the corresponding object. Each permission is
associated with a set of verifiers. In order to be granted a given
permission, a request must satisfy at least one of the verifiers in
this set.

\subsubsection{Storage Servers}
\label{chap:tutamen:platform:arch:ss}

Tutamen storage servers (SS) are responsible for storing all or part
of each Tutamen secret. Figure~\ref{fig:tutamen:storagestructs} shows
the core storage server data structures.

\begin{figure}[t]
  \centering
  \includegraphics[width=0.48\textwidth]{./figs/out/Tutamen-Structs-SS.pdf}
  \caption{Storage Server Data Structures}
  \label{fig:tutamen:storagestructs}
\end{figure}

The top-level data structure employed by storage servers is the
``collection''. A collection represents a logical grouping of one or
more secrets (or parts of secrets). Associated with each collection is
a list of one or more access control servers delegated with enforcing
the access control requirements for the collection. Access control
granularity is thus set at the per-collection, not per-secret level. A
collection is also capable of storing user-provided metadata to aid in
the mapping of collections to the objects for which they store
secrets.

Each collection stores one or more secrets or secret shards. These
secrets consist of the actual secret data the applications leveraging
Tutamen wishes to store as well as any associated user-provided
metadata. Since access control is set at the per-collection level,
secrets inherit the access control characteristics of the
corresponding collection.

How best to map secret data to collections is left up to each
application. This decision is primarily driven by the fact that access
control is performed on the per-collection level. Thus, if an
application requires that a set of secrets always have a common set of
access control requirements (e.g., per-sector encryption keys for an
encrypted block device), it become efficient to group these secrets
into a single collection. Doing so minimizes the complexity of trying
to keep access control requirements synced across multiple secrets,
and increases performance by minimizing the number of requests that
the applications must make to secure tokens from the access control
server. In cases where each secret requires its own access control
requirements (e.g., per-file encryption keys), it is appropriate for
the corresponding application to store only a single secret per
collection.

\subsubsection{Access Control Protocol}
\label{chap:tutamen:platform:arch:acp}

Access control servers control access related to both internal (i.e.,
access control server) and external (i.e., storage server) objects by
providing signed authorization tokens in response to valid
requests. Similar to previously proposed distributed and federated
access control systems~\cite{Calero2010, Leandro2012}, each
authorization token grants the bearer a specific permission related to
a specific object. Unlike previous systems, however, Tutamen is
designed to avoid needing to trust any single access control provider
(see \S~\ref{chap:tutamen:platform:arch:distributed}).
Figure~\ref{fig:tutamen:systembase} shows the basic communication
involved in the Tutamen access control process.

\begin{figure}[t]
  \centering
  \includegraphics[width=0.48\textwidth]{./figs/out/Tutamen-System-Base.pdf}
  \caption{Access Control Communication}
  \label{fig:tutamen:systembase}
\end{figure}

Each access control server generates authorization tokens in response
to a client sending an authorization request. Each authorization
request (and each corresponding token) includes two claims binding it
to a specific object: the object type and the object ID. Each token
request also contains a claim that binds it to a specific permission
(e.g., read, write, delete, modify) for the corresponding
object. Authorization requests are further bound to the specific
client making the request (authenticated via mutual-TLS), and to an
expiration time after which the token is no longer valid.

Upon receiving an authorization request from a client, the access
control server looks up the permission group for the corresponding
object (identified via the combination of object type and object ID)
and then loads the verifier set corresponding to the requested
permission. The server then traverses each verifier in this set,
verifying both client membership in one of the accounts listed in the
verifier as well as executing any authenticator modules required by
the verifier until it finds (or fails to find) a verifier that is
satisfied by the request. If the server is able to verify compliance
with at least one verifier, it grants the authorization request and
returns a signed authorization token that includes the object type,
object ID, granted permission, and expiration time. The bearer of this
token can then present it in conjunction with a request to either the
access control server or a storage server in order to be granted the
right to perform an approved action on the corresponding object.

Other than the bootstrapping operations and the token request
operations themselves, all requests to either storage or access
control servers must be accompanied by a valid token. The receiving
server validates this token using the public signing key of the
associated AC server; for requests to the AC sever itself, this key is
available internally. For requests to external storage servers, the
signing key is downloaded by the storage server from the access
control server and cached for future use. In this manner, access
control servers are responsible both for granting and verifying
authorization requests and signing the corresponding tokens, as well
as for verifying tokens accompanying requests to perform actions on
ACS objects (e.g., to create or modify verifiers or accounts). Storage
servers are responsible only for verifying tokens accompanying
requests to perform actions on SS objects (e.g., to create a collection
or read a secret).

\subsubsection{Distributed Usage}
\label{chap:tutamen:platform:arch:distributed}

Tutamen is designed to be used in both centralized and distributed use
cases. The simplest Tutamen arrangement (e.g., as shown in
Figure~\ref{fig:tutamen:systembase}) involves leveraging a single
Tutamen access control server and a single storage server. In this
arrangement, the storage server stores a complete copy of each secret
while the access control server is solely charged with enforcing
access to these secrets. While this use case is easy to deploy, it has
two notable downsides. First, it forces the user to place a high
degree of trust in the operator of the access control server (who has
complete control over whether or not the access control rules for a
given secret are being faithfully enforced), as well as in the
operator of the storage server (who, likewise, must faithfully verify
incoming tokens and avoid otherwise leaking secret data). Second, it
lacks any form of redundancy -- if either the access control server or
the storage server is unavailable, applications will be unable to
retrieve any secrets.

A variety of systems have been proposed with the goal of minimizing
trust requirements for cloud infrastructure~\cite{bessani2011,
  kallahalla2003, kubiatowicz2000, mahajan2011,
  wilcox-o'hearn2008}. Tutamen applies similar ``minimal-trust'' goals
to the secret storage problem by offering support for a distributed
operation mode as an alternative to single-server operation. Operating
Tutamen in a distributed manner is largely a task that is pushed down
to the application (or client library). With the exception of offering
the necessary primitives to support such operation, both Tutamen
storage and access control servers are designed to be largely agnostic
as to whether they are being used in a centralized or a distributed
manner. This design has the benefit of avoiding server-side scaling
challenges, allowing the extra overhead required for distributed
operation to be supported by each application that requires it.

\begin{figure}[t]
  \centering
  \includegraphics[width=0.48\textwidth]{./figs/out/Tutamen-System-Distributed.pdf}
  \caption{Distributed Operation}
  \label{fig:tutamen:systemdistributed}
\end{figure}

Figure~\ref{fig:tutamen:systemdistributed} shows the basic layout of a
distributed Tutamen setup. In such a setup, the Tutamen application
first shards its secret using a $(k, n)$ threshold
scheme~\cite{krawczyk1993, shamir1979}, similar to other proposed
``minimal trust'' cloud systems~\cite{bessani2011} as well as
previously proposed ``key escrow'' systems~\cite{blaze1996,
  denning1996}. The application chooses the value of $n$ based on the
number of storage servers it wishes to utilize. The value of $k$ is
then chosen to control how many of the servers must be responsive in
order to retrieve the secret; i.e., the difference between $n$ and
$k$ controls how much storage redundancy the system has by dictating
the number of storage servers that can be unavailable before access to
the secret itself is lost. The application then pushes each shard to
the $n$ storage servers. If the application is merely concerned about
storage redundancy, or about their ability to trust a storage server
operator, it can delegate the access control for each secret shard to
a single access control server. To retrieve such a secret the
application would request the necessary token from the access control
server and include it in its request to each storage server for their
respective shard of the secret. When the application receives a
response from $k$ of the storage servers, it is able to reconstruct
the original secret.

In most cases, however, we imagine that in addition to wishing to
mitigate storage server trust and reliability failures, the
application will also wish to protect itself against access control
server trust and reliability failures. This is accomplished via
storage server support for the specification of two pieces of access
control metadata corresponding to each stored collection: a list of AC
servers approved to provide access control tokens for the collection
and a minimum number of servers from which valid tokens must be
received. These parameters form the basis of a novel $(k, n)$
threshold scheme for access control servers -- e.g., a collection may
delegate a list of $n$ access control servers from which an
application must acquire at least $k$ valid tokens in order to gain
access. Thus, if the user does not wish to trust a single access
control server, they may require tokens from at least $k$ different AC
servers in order to access the data stored in a given
collection. Likewise, if the application wishes to withstand the
failure of one or more AC servers, it can specify $n$ possible AC
servers where $n > k$.

In order to facilitate ease of management when operating in a
distributed mode, Tutamen also supports allowing applications to
request specific UUIDs~\cite{leach2005} for each object at creation.
This allows clients to use the same object ID across multiple servers,
alleviating the burden of maintaining a mapping between object IDs and
the servers to which they correspond. Using the same object IDs across
multiple servers also allows for more efficient token management --
e.g., if an application uses the same collection ID on three separate
storage serves, all of which delegate a common set of access control
servers, it's possible (and desirable) for the application to use a
single token granting access to the relevant collection ID on all
three servers. Without this capability, an application would be forced
to request multiple tokens from each access control server
corresponding to the collection ID used on each storage
server.\footnote{The ability to request specific object IDs does have
  one downside: it opens Tutamen up to a possible denial-of-service
  (DoS) attack where an attacker attempts to request the object IDs
  they know another application wishes to use for themselves. Since
  each server may only use each object ID once, the first application
  to request a given UUID gets it. Thus, if an adversary knew which
  object IDs a given application planned to use, they could request
  these object IDs on a set of AC servers for themselves, depriving
  the original application of the ability to use those
  servers. Nonetheless, we believe the convenience afforded by
  allowing applications to request specific object IDs outweighs the
  potential for DoS abuse.}

\subsection{Implementation}

In order to demonstrate and test the Tutamen platform we've created
reference implementations for the storage server, access control
server, and several client libraries.

Our Tutamen server implementation exposes a RESTful
interface~\cite{fielding2000} for both the access control and storage
server APIs. This interface both accepts and responds using
JSON~\cite{json} messages over the HTTPS protocol. The full access
control server API specification as well as the API reference
implementation source code is available online
at~\cite{src-tutamen-apiaccesscontrol}. Likewise, the storage server
API specification and source code can be found
at~\cite{src-tutamen-apistorage}. Both implementations are freely
available under the terms of the AGPLv3. The prototype servers are
written in Python 3 using the Flask web
framework~\cite{python-flask}. For simplicity, both servers are
designed to be served via WSGI~\cite{pep3333} using the Apache HTTP
Server~\cite{apache} for TLS termination and client-certificate
verification.

Both Tutamen servers rely on a shared \texttt{pytutamen-server} python
library for the implementation of their core logic. The
\texttt{pytutamen-server} source is available
at~\cite{src-tutamen-pytutamenserver} under the terms of the
LGPLv3. This library leverages the Redis~\cite{redis} key-value store
for persistent storage. Our Tutamen implementation adopts the JSON Web
Signature (JWS)~\cite{rfc7515} and JSON Web Token (JWT)~\cite{rfc7519}
specifications for exchanging cryptographically authenticated tokens
between Tutamen applications, access control servers, and storage
servers. We leverage the pyjwt~\cite{pyjwt} library for JWS and JWT
support. These tokens are then attached to subsequent requests using a
\texttt{tutamen-tokens} header field.

The access control servers expose a pluggable authenticator interface
through which end users and other developers may add custom
authentication functionality. This interface is similar in purpose to
previous pluggable authentication interfaces such as
PAM~\cite{samar1996}. The Tutamen authenticator interface is primarily
designed for providing authentication checks beyond the TLS
certificate-based authentication the access control server
automatically performs on every request for the purpose of associating
each request with a specific client and account. As an example, we've
implemented an authenticator module that allows users to approve
Tutamen token requests via SMS text message using the
Twilio~\cite{twilio} messaging platform. We also envision
authenticator modules for enforcing access control rules such as only
allowing requests during certain times of day or from specific network
addresses. Each authenticator plugin is provided with both a set of
per-instance configuration data (e.g., to whom an SMS message gets sent
for approval) as well as all of the details of a specific token
request including both the IDs and metadata associated with the
requesting account and client (e.g., from which information such as
originating IP address or time of day can be extracted).

In addition to the server and authenticator implementations, we've
also created reference Tutamen client libraries for both
Python~\cite{src-tutamen-pytutamen} and
Go~\cite{src-tutamen-go}. Using the Python client library, we've
created a reference Tutamen CLI through which users may directly
store/retrieve secrets and control secret sharing and access control
rules. The CLI is useful for managing Tutamen objects even in cases
where other applications (e.g., those discussed in
Section~\ref{chap:tutamen:apps}) are set up to interface directly with the
Tutamen platform. In this manner, it's not necessary for every Tutamen
application to implement all Tutamen functionality. Instead, an
application might leverage only the necessary Tutamen commands to
perform secret storage and retrieval, leaving the task of managing the
sharing of Tutamen-stored secrets to the CLI or to another dedicated
management application.

\subsection{Usage Example}

\begin{figure}[!t]
  \centering
  \begin{subfigure}[t]{0.48\textwidth}
    \includegraphics[width=\textwidth]{./figs/out/Tutamen-Op-Store.pdf}
    \caption{Storing a New Secret}
    \label{fig:tutamen:ops:store}
  \end{subfigure}
  ~
  \begin{subfigure}[t]{0.48\textwidth}
    \includegraphics[width=\textwidth]{./figs/out/Tutamen-Op-Fetch.pdf}
    \caption{Retrieving an Existing Secret (w/ SMS Auth)}
    \label{fig:tutamen:ops:fetch}
  \end{subfigure}
  \caption{Tutamen Operations}
  \label{fig:tutamen:ops}
\end{figure}

To illustrate the interaction of the various components of the Tutamen
platform, we present an example of the steps taken by an application
to store and then retrieve a secret via Tutamen. In this example, we
assume the application is using three storage servers and two access
control servers as shown in
Figure~\ref{fig:tutamen:systemdistributed}. We also assume the
application has already bootstrapped an account and client (i.e., it
previously contacted the AC servers with a request to create a new
account and associated client).

Figure~\ref{fig:tutamen:ops:store} shows the steps required to
create a new collection and store a secret within it. We assume the
application has already sharded the secret into three parts -- one per
server.\footnote{Omitted from this diagram is the process of creating
  verifiers and permissions groups for the collection verifier
  itself. These permissions groups are necessary to control who can
  read, modify, or delete the corresponding verifier after
  creation. The process for creating said structures is similar to the
  process of creating the collection-related verifier and permissions
  group shown. To avoid the infinite recursion of needing verifiers
  for each verifier, it's possible for a verifier to be associated
  with a permissions group in which it is itself a member (i.e., a
  verifier can enforce its own access control specification).}

Figure~\ref{fig:tutamen:ops:fetch} shows the steps required to
retrieve an existing secret. This diagram also assumes that the secret
in question has an SMS authenticator associated with it, requiring a
user to provide a response to an SMS challenge approving access to the
secret.

\section{Security and Trust}
\label{chap:tutamen:trust}

One of Tutamen's primary design goals is its ability to support a wide
range of security and trust requirements. It achieves this goal
through its support for both centralized and distributed operation as
well as though its support for a range of authentication mechanisms.

\subsection{Security of Individual Servers}

The security of each individual access control server rests on several
requirements. Failure to uphold these requirements will result in the
failure of any security guarantees provided by the AC server.

\begin{packed_desc}
\item[Certificate Authority Role:] Each access control server acts as
  a CA delegated with issuing and verifying client certificates. Thus,
  each AC server must store its CA keys in a secure manner and
  faithfully verify the certificate presented by each client
  connection.
\item[Token Issuance and Verification:] Each access control server is
  responsible for verifying the access control requirements bound to
  specific object/permission combinations, issuing signed tokens
  attesting to such verification, and verifying the signatures of the
  tokens it receives from clients wishing to operate on access control
  objects. Thus, each AC server must store private token signing key
  in a secure manner and faithfully verify both the access control
  requirements governing specific token requests as well as the
  signatures on all incoming tokens.
\end{packed_desc}

The storage servers must uphold the following security
requirements. Failure to do so results in a failure of the security of
the storage server.

\begin{packed_desc}
\item[Token Verification:] Each storage server must securely (via
  HTTPS) obtain the public token signing key from each AC server
  delegated with providing access control for a given storage
  object. The storage server must then use these keys to faithfully
  verify the signatures on all tokens it receives. Assuming the token
  signature is valid, the storage server must faithfully enforce the
  claims asserted in a given token; e.g., by only allowing actions
  granted by the permission contained in the token on the object the
  token identifies prior to the expiration time specified by the
  token.
\item[Secure Storage:] Each storage server must take steps to store
  user-provided secrets in a secure manner, releasing them only to
  requests accompanied by the requisite number of valid tokens
  granting such release.
\end{packed_desc}

Since the tokens the storage server must verify are provided by the AC
servers, the security of the storage server with respect to a given
collection is dependent on the security of any designated AC servers
associated with said collection. If these AC servers are insecure, the
objects that delegate access to them will also be insecure.

\subsection{Security of Multiple Servers}

Unlike existing secret management systems~\cite{vault, confidant,
  keywhiz}, the Tutamen architecture is capable of remaining secure
even when individual storage or access control servers fail to meet
their security requirements. Such failures may result from physical
server compromise, software bugs, malicious intent or incompetence on
the part of the server operator, or compelled failures.\footnote{For
  example, being forced to turn over stored secrets in response to
  legal or governmental pressure.}

To work around security failures of individual server, Tutamen
applications can leverage Tutamen's distributed operation modes. In
these modes, the security of the system as a whole is diffused, no
longer relying on the security of any specific access control or
storage server in order to keep an application's secrets secure. As
described in Section~\ref{chap:tutamen:platform:arch:distributed},
each application can distribute both secret storage and access control
delegations using $n$ choose $k$ schemes. In such setups, the
difference between $n$ and $k$ represents the degree to which a
Tutamen applications can withstand security failures of the associated
AC and storage servers. For example, an application which chooses to
shard its secrets across five storage servers where any three shards
are sufficient to recreate the secret ($n=5$, $k=3$) will continue to
remain secure even if two of the storage servers fail to meet their
security obligations. Similarly, if each secret shard delegates five
possible AC servers, tokens from three of which are required to grant
secret access, the applications can withstand the failure of two AC
servers to uphold their security guarantees.

\subsection{Trust Model}

Trust in Tutamen follows from the security models of both individual
Tutamen servers and of the distributed Tutamen deployment
architectures. If a Tutamen application is leveraging only a single
storage and AC server, the application is placing a high degree of
trust in both servers (and by proxy, the operators of both
servers). This level of trust may be appropriate for some use cases
(e.g., when a user is operating their own Tutamen's servers), but is
inappropriate in many other cases (e.g., when using third party hosted
Tutamen servers). Fortunately, Tutamen allows applications to avoid
placing a high degree of trust in any single server by leveraging
multiple servers and picking $k$ and $n$ in a manner commensurate with
the degree to which each server is trusted.

Beyond minimizing the amount of trust placed in each individual
Tutamen server by leveraging multiple servers, we also envision
economic incentives helping to ensure Tutamen server
trustworthiness~\cite{anderson2001}. The Tutamen protocol is
standardized and designed to support a range of interchangeable ACS
and SS providers. Such a design allows for the development of a
Tutamen server marketplace where both ACS and SS providers can compete
against each other on the basis of trustworthiness, features (e.g.,
what types of authenticators they support), and cost. In such an
ecosystem, Tutamen service providers who fail to uphold the Tutamen
security requirements on their servers will suffer a negative economic
effect, disincentivizing such behavior. It is also likely that storage
providers who take additional steps to protect the secrets they store
(e.g., by using systems such as Trusted Platform Modules (TPMs) to
encrypt the secrets they hold and harden server security) would be
able to command a higher price in the marketplace, incentivizing such
best practices.

Thus, unlike other third-party cloud services where trustworthiness
and economic incentives are in direct competition (as is the case on
many ``free'' third part services that depend on selling user data in
order to generate revenue)~\cite{flowerday2006}, Tutamen encourages a
system where economic incentives are well aligned with user
trust. That fact, coupled with the high degree of control over
third-party trust Tutamen grants to each application by allowing each
application to select how many servers to diffuse trust across, make
Tutamen a robust system in the face of both security and
trustworthiness failures. Such robustness is a critical component of
any successful secrete storage system.

\section{Applications}
\label{chap:tutamen:apps}

Tutamen is designed to support a wide range of applications. We have
integrated our reference Tutamen design with a set of common
applications for the purpose of demonstrating the value derived from
using a secure storage system such as Tutamen. These applications all
leverage Tutamen's flexibility to achieve functionality that would
have been difficult or impossible to achieve without using a system
like Tutamen.

\subsection{Block Device Encryption}

Block device encryption systems are a popular means of protecting the
data stored on computing systems in the event that the system is lost,
stolen, or otherwise physically compromised.  Block-level encryption
systems such as dm-crypt~\cite{dm-crypt} (generally coupled with the
Linux Unified Key Setup (LUKS)~\cite{luks} container) or the
QEMU~\cite{qemu} qcow2 encryption system provide methods for securing
the data stored on laptops, desktops, and VMs. Such systems
traditionally bootstrap security by requiring the user to enter a
password at boot-time to unlock a locally stored encryption key which
is then used to decrypt the block device in question. Unfortunately,
the ``human-at-keyboard'' security root make such systems difficult or
impossible to use atop headless servers or in related situations where
no human can be expected to be present at boot-time. We've leveraged
Tutamen to overcome this barrier.

To add Tutamen-support to LUKS/dm-crypt we've created a Tutamen-aware
implementation~\cite{src-tutamen-askpassword} of the \texttt{systemd}
Password Agent Specification~\cite{systemd-passwordagents}. This
specification is used by LUKS/dm-crypt \texttt{cryptsetup} utility to
request the necessary decryption secret. At boot time,
\texttt{cryptsetup} will send out a request for this secret. Normally
this triggers a ``human-at-keyboard'' prompt for a boot
pass-phrase. Our Tutamen-aware password agent can instead respond to
such requests by retrieving the necessary decryption secret from a
Tutamen storage server (after first retrieving the necessary tokens
from the corresponding Tutamen AC server). In addition to modifying
the ask-password utility, we made several modifications to the
\texttt{initrd} creation process to add Tutamen networking support,
the necessary Tutamen client TLS key pair, and a config file
specifying which Tutamen servers to use and the UUIDs of the relevant
Tutamen collection and secrets.

We've also integrated Tutamen support with QEMU to provide qcow2
encryption keys when a VM boots~\cite{src-qemu-tutamen}. Similar to
the dm-crypt setup, QEMU normally requires the user to provide the
encryption key via the QEMU console when a VM launches. Our system
replaces this ``human-at-keyboard'' process with Tutamen-based secret
retrieval. In addition, QEMU currently requires the user to provide
the full encryption key, not just a pass-phrase to unlock a pre-stored
key~\cite{berrange-qemucrypto}. This has negative security
repercussions in the common case where users pick short password-like
keys. Using Tutamen, we can overcome this barrier since Tutamen
servers have no qualms about needing to store or remember sufficiently
long encryption keys. Our system thus increases both QEMU's security
and its ease of use.

Using these setups, we're able to boot servers and VM images with
encrypted disks without requiring a human to be physically present at
the machine. In cases where we still desire human approval of the boot
process, we can leverage our SMS authenticator module to get an
on-demand confirmation from a designated human as a prerequisite to
Tutamen releasing the correct key. This allows us to gain the same
level of human-in-the-loop security provided by a typed pass-phrase,
but without actually requiring a human to go to the datacenter to type
one in. In situations where we don't desire a human-in-the-loop at
all, we envision automating the approval process via the use of
time-of-day and IP-source authenticators.

\subsection{Encrypted Cloud File Locker}

Cloud-based file lockers such as Dropbox~\cite{dropbox} are extremely
popular today. Unfortunately, these systems require users to trust the
cloud provider with full access to their (generally unencrypted)
data~\cite{vintsurf-dropbox}. Users wishing to overcome this
deficiency can optionally encrypt all of their data on the client
before syncing it to the file locker provider, but doing so does not
generally interact well with such services' sharing and multi-device
use cases, requiring users to employ manual, out-of-band key
exchange mechanisms to share or sync their encrypted files. We don't
believe file locker users should have to choose between easily syncing
or sharing their files and using encryption to protect their data.

Tutamen provides a solution to this problem by offering a secure
key-sharing mechanism. Instead of manually distributing or sharing
encryption keys, the user can store their key as a Tutamen secret and
leverage Tutamen's access control features to share the secret with
the accounts of their friends. This entire process could even be
automated such that when a user shares a file via Dropbox, the
corresponding encryption key is automatically shared via Tutamen.

Toward this end, we have created FuseBox: an alternate Dropbox client
that performs client-side encryption of all Dropbox files, storing the
corresponding encryption keys on our reference Tutamen server. FuseBox
achieves goals similar to those achieved by~\cite{goh2003}, but
without requiring out-of-band key management. Similar to other
file-system-level encryption systems~\cite{blaze1993, Cattaneo2001,
  halcrow}, FuseBox provides transparent file encryption to end
users. In order to avoid the storage space and security challenges
presented by locally caching all Dropbox data (i.e., the operation mode
for the official Dropbox client), FuseBox uses AES~\cite{daemen1999,
  nist2001} as a stream cipher to transparently stream and encrypted
data to/from Dropbox's servers on demand.  The source code for our
FuseBox implementation is available at~\cite{fusebox}.

Since FuseBox leverages Tutamen to store each per-file encryption key,
it becomes possible to share an encrypted file via Dropbox, share its
encryption key via Tutamen, and achieve the same level of
functionality traditional Dropbox users have without having to expose
one's data to Dropbox. While the key sharing process in FuseBox is not
yet directly synced with Dropbox's file sharing system, the Tutamen
CLI can be used to quickly share the encryption keys between users. In
this manner, we've used FuseBox to store and share encrypted files
with nearly the same ease with which one might use the traditional
unencrypted Dropbox client. By leveraging Tutamen, FuseBox also gains
the ability to remotely revoke file access, e.g., in the case a device
is lost or stolen, similar to systems such as~\cite{geambasu2011}. We
also have plans to add cryptographic file authentication to FuseBox's
streaming architecture using techniques such as those described
at~\cite{McGrew2005}. FuseBox, via Tutamen's distributed operation
mode, also avoids the sharing pitfalls associated many existing
``secure cloud storage'' providers~\cite{wilson2014} by avoiding
reliance on a single trusted party to facilitate sharing operations.

\subsection{Other}

Since our Tutamen-capable ask-password port speaks the standard
systemd Password Agent protocol, it can also be used to provide
Tutamen-backed pass-phrase storage to any applications leveraging this
protocol, including OpenVPN and various password storage utilities. We
have not yet thoroughly explored these use cases, but we envision a
Tutamen-passed systemd password agent being useful in a wide range of
situations beyond just full disk encryption. Our experience
integrating the systemd password agent with Tutamen also suggests that
Tutamen would provide a useful backend for a variety of other
``agent'' protocols (e.g.,~\cite{cox2002, ylonen1996}).

\section{Performance}
\label{chap:tutamen:performace}

\begin{figure}[!t]
  \centering
  \begin{subfigure}[t]{0.48\textwidth}
    \includegraphics[width=\columnwidth]{./figs/pre/Tutamen-Chart-Timings.png}
    \caption{Timings for Tutamen Operations}
    \label{fig:tutamen:charts:timings}
  \end{subfigure}
  ~
  \begin{subfigure}[t]{0.48\textwidth}
    \includegraphics[width=\columnwidth]{./figs/pre/Tutamen-Chart-IOPS.png}
    \caption{Throughput vs Latency Curves}
    \label{fig:tutamen:charts:iops}
  \end{subfigure}
  \caption{Tutamen Performance}
  \label{fig:tutamen:charts}
\end{figure}

We've evaluated Tutamen in a variety of scenarios using the
applications described in \S~\ref{chap:tutamen:apps}. These scenarios have
proven Tutamen's usefulness as an enabler of previously unattainable
functionally. While Tutamen is still a prototype, we feel it provides
a well-designed architecture capable of supporting a wide range of
practical secret storage applications. While the server software has
not yet been optimized for performance, we have performed a number of
performance measurements in order to better understand the relative
computational load and bottlenecks of the various parts of the Tutamen
system.

Figure~\ref{fig:tutamen:charts:timings} shows the time required to complete two
of the most common Tutamen operations: storing a new secret and
retrieving a previously stored secret. We profiled the amount of time
the Tutamen CLI application spent performing various parts of each of
these two Tutamen operations. In both operations, the bulk of the
wait-on-server-related run time is spent requesting and retrieving the
authorization tokens required to complete the associated
operations. In the secret creation case, five tokens are required. In
the secret read case, only a single token is required. The remainder of
the server-related time is spent either creating AC and storage data
structures (as in the store secret case), or reading existing data
structures (as in the retrieve secret case). The ``other'' time is
spent reading the Tutamen config files, loading the necessary client
certificates, and dealing with the overhead required to interpret the
python-based CLI.

It is not unexpected that the client must spend the bulk of its time
requesting tokens and waiting for them to be approved -- token
verification is the primary role the access control server must
perform, and depending on the complexity of the verifiers associated
with the permission the token is requesting, verification can be a
fairly complex task. When performing these measurements, we employed a
simple verifier that only required client membership in a specific
account. Verifiers that include human-in-the-loop authenticators
(e.g., SMS approval) would increase the token turnaround time by the
amount of time the human requires to provide approval. Thus, it is
important that Tutamen applications treat token approval as an
operation that can take anywhere from under a second to human-scale
times (e.g., 10s of seconds). To help alleviate these waits on
applications that must perform a high number of Tutamen requests,
Tutamen tokens may be reused up until their expiration time. Thus, it
is possible for an application to request a long-lived token and to
reuse this token to access multiple secrets within the collection to
which the token grants read access.

Figure~\ref{fig:tutamen:charts:iops} shows the request rate vs response time
(with standard deviations) of a token request operation, two ``null''
AC API operations (one that sends and verifies the client TLS
certificate and one that does not), and a fetch secret operation. Raw
Apache HTTPS and HTTP curves are also shown for comparison. As these
curves show, token verification of our prototype server tops out at
around 40 requests/second (rps) on a modest server (2-core, 4GB VM
running atop 2011-era Intel Xeon hardware). The null AC API operation
with client certificates tops out around 90 rps, and the null
operation without client certificates tops out at about 110 rps. Raw
HTTPS tops out around 120 rps. HTTP topped out around 5000 rps (curve
truncated for viewability). The current server setup is thus primarily
limited by the crypto overhead required to serve the application and
verify client certificates using TLS. Token verification itself also
incurs additional computational requirements - including cryptographic
signing operations, but is well within the order of magnitude of the
underlying server limits. Secret retrieval (after acquiring a token)
is relatively quick, topping out at around 100 rps.

While these levels of performance would not likely meet the
requirements of a production-level Tutamen AC server, they have been
perfectly adequate for supporting the handful of Tutamen applications
we're currently using. Since most of our Tutamen applications require
only a single Tutamen secret retrieval at relatively rare rates (e.g.,
once per server reboot or once per file open), the 40+ requests per
second our AC server can provide have been more than adequate for our
needs. We've also designed our reference server to be horizontally
scalable (e.g., by spinning up multiple load-balanced API servers that
share a common database). That scalability, coupled with future
performance-related code optimization, leads us to believe the Tutamen
server infrastructure can be adopted to meet the needs of larger
installations with only moderate effort.


%%  LocalWords:  HashiCorp's Lyft's Keywhiz TPMs QEMU's Xeon Tutamen
%%  LocalWords:  viewability Custos ACS HTTPS CSR CSRs authenticators
%%  LocalWords:  Authenticators verifiers authenticator DoS AGPLv JWS
%%  LocalWords:  pytutamen LGPLv Redis JWT pyjwt tutamen SMS Twilio
%%  LocalWords:  Auth Tutamen's dm QEMU qcow systemd cryptsetup
%%  LocalWords:  initrd FuseBox FuseBox's OpenVPN
